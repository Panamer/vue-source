{"version":3,"file":"vue.js","sources":["../src/observer/array.js","../src/utils.js","../src/observer/index.js","../src/state.js","../src/compiler/parser.js","../src/compiler/generator.js","../src/compiler/index.js","../src/observer/scheduler.js","../src/observer/watcher.js","../src/vdom/patch.js","../src/lifecycle.js","../src/init.js","../src/vdom/create-element.js","../src/render.js","../src/index.js"],"sourcesContent":["/**\n * 对数组的7个方法做函数劫持, 为什么是这7个呢? 因为只有他们能改变数组本身\n * ⚠️ 在实际应用中 操作数组索引改变数组 vue是检测不到的  list[0] = 100 ❌\n * 原理: 复制数组原型上的方法 对其中7个做函数劫持 AOP\n * 先执行自定义方法 再触发原型上的方法 apply \n */\n\nlet oldArrayMethods = Array.prototype;  // 获取数组原型上的方法\n\n// 创建一个全新的对象, 根据原型链可以找到数组原型上的方法, 而且拓展方法时 不会影响原数组的原型方法\nexport let arrayMethods = Object.create(oldArrayMethods)\n\nlet methods = [\n    'push',\n    'pop',\n    'unshift',\n    'shift',\n    'splice',\n    'sort',\n    'reserve'\n]\n\nmethods.forEach(method => {\n    arrayMethods[method] = function (...args) {\n        const ob = this.__ob__\n        let result = oldArrayMethods[method].apply(this, args)\n        let inserted;\n        switch (method) {\n            case 'push':\n            case 'unshift':\n                inserted = args\n                break;\n            case 'splice':\n                inserted = args.slice(2);\n                break;\n            default:\n                break;\n        }\n        inserted && ob.observeArray(inserted)\n        console.log('数组被观测了', inserted);\n        return result;\n    }\n})\n/**\n * 为什么7个方法 只对三个做了处理呢?\n * 因为 push、unshift、splice  可以新增属性. 其他几个不能新增\n * 做响应式处理的目标是对所有数据观测, 所以不是新增的数据 不用处理.虽然其他的方法也能让数组改变\n * 注意: 这一步只做观测, 使页面更新的是  触发依赖 不要混淆.\n * 观测和页面更新没有直接关系,观测是为收集、触发依赖做铺垫\n */","// 此处放所有的工具方法\n\n\nexport function isObject(obj) {\n    return typeof obj === 'object' && obj !== null\n}\nconst LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'mounted',\n    'beforeUpdate',\n    'updated'\n]\nlet strats = {};\nfunction mergeHook(parentVal,childVal){ // []\n    if(childVal){ // 如果 孩子有值 \n        if(parentVal){ // 父亲有值 就直接拼接\n            return parentVal.concat(childVal)\n        }else{ // 如果孩子有值父亲没值 就将孩子包装成数组\n            return [childVal] // Vue.options.beforeCreate = [childVal]\n        }\n    }else{\n        return parentVal; // 直接返回父亲，因为没有孩子  \n    }\n}\nLIFECYCLE_HOOKS.forEach(hook=>{\n    strats[hook] = mergeHook\n})\nexport function mergeOptions(parent,child){ // {...parent,...child}  {a:1.b:2}  {a:{a:{b:2}}}\n    const options = {}\n    // 如果父亲和儿子里都有一个属性 这个属性不冲突 \n    for(let key in parent){ // 处理父亲的所有属性\n        mergeField(key);\n    }\n    for(let key in child){ // 处理儿子的所有属性，如果父亲有的值 在第一个循环中就已经处理了\n        if(!parent.hasOwnProperty(key)){\n            mergeField(key);\n        }\n    }\n    function mergeField(key){\n        // 两个组件间 data是函数 \n\n        // 写代码时很忌讳 各种if else if else \n\n        // 策略模式 根据不同的属性 调用不同的策略  \n        if(strats[key]){\n            // 这里就包含了 mergeHook的逻辑\n            options[key] = strats[key](parent[key],child[key])\n        }else if(isObject(parent[key]) && isObject(child[key])){\n            options[key] = Object.assign(parent[key],child[key])\n        }else{\n            if(child[key] == null){\n                options[key] = parent[key];\n            }else{\n                options[key] = child[key]; // 用儿子的值 直接覆盖掉 父亲的值\n            }\n        }\n    } // 面试时 经常会提到对象间的合并\n    return options\n}\n","import { arrayMethods } from \"./array\";\nimport {isObject} from '../utils.js'\n\n/**\n * 为什么vue用function 这里用class? \n * 因为 Function构造函数方便扩展原型上的属性和方法, 这里不需要\n */\nclass Observe {\n    constructor(data) {\n        /**\n         * 1、添加一个__ob__响应式标示,代表data已经被观测过, 对象数组都有\n         * 2、data.__ob__  = this\n         * 在数据上就可以获取到ob属性, 指代的是 observe实例\n         */\n        Object.defineProperty(data, '__ob__', {\n            enumerable: false,\n            configurable: false,\n            value: this\n        })\n        /**\n         * 因为实际开发中通过索引操作数组的情况并不多, 如果这里通过拦截数组的索引 做响应式太浪费性能\n         * 所以 vue采用 函数劫持的方法 重写了 7个能改变数组本身的方法\n         * 这里判断一下是 对象 or 数组\n         * 利用原型链向上查找的特性,使得数组改变的方法从arrayMethods中取到\n         */\n        if (Array.isArray(data)) {\n            data.__proto__ = arrayMethods;\n            this.observeArray(data)\n        } else {\n            this.walk(data)\n        }\n    }\n    /**\n     * 无论数组还是对象, 都要遍历其中的每一项 做响应式处理\n     */\n    observeArray(data) {\n        for (let i = 0; i < data.length; i++) {\n            observe(data[i]);\n        }\n    }\n    walk(data) {\n        Object.keys(data).forEach((key) => {\n            defineReactive(data, key, data[key])\n        })\n    }\n\n}\n\n/**\n * vue2.0 有性能问题: 递归重写get set 数据嵌套很大的话 性能很差. vue3 使用proxy得到优化🐂\n * \n */\n\nfunction defineReactive(data, key, value) {\n    observe(value) // value可能还是一个对象 递归循环检测一下\n    Object.defineProperty(data, key, {\n        get() {\n            console.log('对象的get方法');\n            return value\n        },\n        set(newVal) {\n            if (newVal === value) return\n            observe(newVal)\n            value = newVal\n            console.log('对象的set方法');\n        }\n    })\n}\n\n\nexport function observe(data) {\n    // 如果不是对象 就不用做响应式处理\n    if (!isObject(data)) {\n        return;\n    }\n    // 如果有__ob__属性    表示观测过 也直接跳出\n    if (data.__ob__ instanceof Observe) {\n        return;\n    }\n    // 返回一个observe实例, 观测的核心代码在这里, 一个对象 对应一个ob实例 \n    return new Observe(data)\n}","import { observe } from './observer/index'\nexport function initState(vm) {\n    const opts = vm.$options\n\n    if (opts.props) {\n        initProps(vm)\n    }\n    if (opts.methods) {\n        initMethod(vm)\n    }\n    if (opts.data) {\n        initData(vm)\n    }\n\n    function initProps(vm) {\n\n    }\n    function initMethod(vm) {\n\n    }\n    function initData(vm) {\n        // 这里就是如何做数据响应式的源码,首先拿到用户传入的数据\n        let data = vm.$options.data;\n\n        if (typeof data === 'function') {\n            data = vm._data = data.call(vm)\n        } else {\n            data = vm._data = data\n        }\n\n        // 把数据代理到vm实例上, 方便取的时候直接可以 vm.msg\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                proxy(vm, '_data', key)                \n            }\n        }\n        // 观测数据\n        observe(data)\n    }\n\n    function proxy(target, property, key){\n        Object.defineProperty(target, key, {\n            get(){\n                return target[property][key]\n            },\n            set(newVal){\n                target[property][key] = newVal\n            }\n        })\n    }\n}\n","//              字母a-zA-Z_ - . 数组小写字母 大写字母  \nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 标签名\n// ?:匹配不捕获   <aaa:aaa>\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\n// startTagOpen 可以匹配到开始标签 正则捕获到的内容是 (标签名)\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\n// 闭合标签 </xxxxxxx>  \nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div>\n// <div aa   =   \"123\"  bb=123  cc='123'\n// 捕获到的是 属性名 和 属性值 arguments[1] || arguments[2] || arguments[2]\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的\n// <div >   <br/>\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 >\n// 匹配动态变量的  +? 尽可能少匹配\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\nexport function parseHTML(html) {\n    // ast 树 表示html的语法\n    let root; // 树根 \n    let currentParent;\n    let stack = []; // 用来判断标签是否正常闭合  [div]  解析器可以借助栈型结构\n    // <div id=\"app\" style=\"color:red\"><span>    helloworld {{msg}}   </span></div>\n\n    // vue2.0 只能有一个根节点 必须是html 元素\n\n    // 常见数据结构 栈 队列 数组 链表 集合 hash表 树\n    function createASTElement(tagName, attrs) {\n        return {\n            tag: tagName,\n            attrs,\n            children: [],\n            parent: null,\n            type: 1 // 1 普通元素  3 文本\n        }\n    }\n    // console.log(html)\n    function start(tagName, attrs) { // 开始标签 每次解析开始标签 都会执行此方法\n        let element = createASTElement(tagName, attrs);\n        if (!root) {\n            root = element; // 只有第一次是根\n        }\n        currentParent = element;\n        stack.push(element);\n    }\n    // <div> <span></span> hello world</div>   [div,span]\n    function end(tagName) { // 结束标签  确立父子关系\n        let element = stack.pop();\n        currentParent = stack[stack.length - 1];\n        if (currentParent) {\n            element.parent = currentParent;\n            currentParent.children.push(element);\n        }\n    }\n\n    function chars(text) { // 文本\n        text = text.replace(/\\s/g, '');\n        if (text) {\n            currentParent.children.push({\n                type: 3,\n                text\n            })\n        }\n    }\n    // 根据 html 解析成树结构  </span></div>\n    while (html) {\n        let textEnd = html.indexOf('<');\n        if (textEnd == 0) {\n            const startTageMatch = parseStartTag();\n\n            if (startTageMatch) {\n                // 开始标签\n                start(startTageMatch.tagName, startTageMatch.attrs)\n            }\n            const endTagMatch = html.match(endTag);\n\n            if (endTagMatch) {\n                advance(endTagMatch[0].length);\n                end(endTagMatch[1])\n            }\n            // 结束标签 \n        }\n\n        // 如果不是0 说明是文本\n        let text;\n        if (textEnd > 0) {\n            text = html.substring(0, textEnd); // 是文本就把文本内容进行截取\n            chars(text);\n        }\n        if (text) {\n            advance(text.length); // 删除文本内容\n        }\n    }\n\n    function advance(n) {\n        html = html.substring(n);\n    }\n\n    function parseStartTag() {\n        const start = html.match(startTagOpen); // 匹配开始标签\n        if (start) {\n            const match = {\n                tagName: start[1], // 匹配到的标签名\n                attrs: []\n            }\n            advance(start[0].length);\n            let end, attr;\n            while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n                advance(attr[0].length);\n                match.attrs.push({ name: attr[1], value: attr[3] || attr[4] || attr[5] })\n            };\n            if (end) {\n                advance(end[0].length);\n                return match;\n            }\n        }\n    }\n\n    return root;\n\n}","const defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\n\nfunction genProps(attrs){  // {id:'app',style:{color:red}}\n    let str = ''\n    for(let i = 0; i<attrs.length; i++){\n        let attr = attrs[i]; // 取到每一个属性\n        if(attr.name === 'style'){\n            let obj = {}; //  color:red;background:green\n            attr.value.split(';').forEach(item=>{\n                let [key,value] = item.split(':');\n                obj[key] = value;\n            });\n            attr.value = obj; // 将原来的字符串换成了 刚才格式化后的对象\n        }\n        str += `${attr.name}:${JSON.stringify(attr.value)},`\n    }\n    return `{${str.slice(0,-1)}}`;\n}\nfunction gen(node){\n    if(node.type === 1){\n        return generate(node)\n    }else{\n        // 文本的处理\n        let text = node.text;\n        if(!defaultTagRE.test(text)){  // 有变量 {{}}\n            return `_v(${JSON.stringify(text)})` // _v('helloworld')\n        }else{\n            let tokens = []; // 每次正则使用过后 都需要重新指定 lastIndex  aaaab\n            let lastIndex =  defaultTagRE.lastIndex = 0;\n            let match,index;\n            while(match = defaultTagRE.exec(text)){\n                index = match.index;\n                // 通过 lastIndex,ndex\n                tokens.push(JSON.stringify(text.slice(lastIndex,index)));\n                tokens.push(`_s(${match[1].trim()})`);\n                lastIndex = index + match[0].length\n            }\n            if(lastIndex < text.length){\n                tokens.push(JSON.stringify(text.slice(lastIndex)));\n            }\n            return `_v(${tokens.join('+')})`\n        }\n        // helloworld {{  msg  }}  aa {{bb}}  aaa   => _v('helloworld'+_s(msg)+\"aa\" + _s(bb))\n    }\n}  \nfunction genChildren(el){ // <div><span></span> hello</div>\n    const children = el.children;\n    if(children){\n        return children.map(c=>gen(c)).join(',')\n    }else{\n        return false\n    }\n}\nexport function generate(el){\n    let children = genChildren(el); // 生成孩子字符串\n    let code = `_c(\"${el.tag}\",${\n            el.attrs.length? `${genProps(el.attrs)}`  : undefined\n        }${\n            children? `,${children}` :''\n        })`;\n\n    return code;\n}\n// 语法级的编译 ","import {parseHTML} from './parser.js'\nimport {generate} from './generator.js';\n\n// template => render函数  实现模版的编译\nexport function compileToFunctions(template) {\n    // 根据模版 通过正则匹配  解析字符串 生成ast抽象语法树  是个object  不同于vnode 表面和vnode很像\n    let ast = parseHTML(template)\n\n    // 核心是字符串拼接 解析ast\n    let code = generate(ast)\n    code = `with(this) { \\r\\nreturn ${code} \\r\\n}`\n    /**\n     * render(){ \n        * with(this){\n        *  return _c('div',{id:app,style:{color:red}},_c('span',undefined,_v(\"helloworld\"+_s(msg)) ))\n        * }\n     * }\n     * 把字符串转换成函数\n     */\n    const render = new Function(code)\n    return render;\n    // 模板编译原理 \n    // 1.先把我们的代码转化成ast语法树 （1）  parser 解析  (正则)\n    // 2.标记静态树  （2） 树得遍历标记 markup  只是优化\n    // 3.通过ast产生的语法树 生成 代码 =》 render函数  codegen\n}","let has = {}; // vue源码里有的时候去重用的是set 有的时候用的是对象来实现的去重\nlet queue = [];\n\n// 这个队列是否正在等待更新\nfunction flushSchedulerQueue() {\n    for (let i = 0; i < queue.length; i++) {\n        queue[i].run();\n    }\n    queue = [];\n    has = {};\n}\n\n\nexport function queueWatcher(watcher) {\n    const id = watcher.id;\n\n    if (has[id] == null) {\n        has[id] = true; // 如果没有注册过这个watcher，就注册这个watcher到队列中，并且标记为已经注册\n        queue.push(watcher);\n        nextTick(flushSchedulerQueue); // flushSchedulerQueue 调用渲染watcher\n\n    }\n}\nlet callbacks = []; // [flushSchedulerQueue,fn]\nlet pending = false;\nfunction flushCallbacksQueue() {\n    callbacks.forEach(fn => fn());\n    pending = false;\n}\n\nexport function nextTick(fn) {\n    callbacks.push(fn); // 防抖\n    if (!pending) { // true  事件环的概念 promise mutationObserver setTimeout setImmediate\n        setTimeout(() => {\n            flushCallbacksQueue();\n        }, 0);\n        pending = true\n    }\n}","import { pushTarget, popTarget } from \"./dep\";\nimport { queueWatcher } from \"./scheduler\";\n\nlet id = 0; // 做一个watcher 的id 每次创建watcher时 都有一个序号 \n// 目前写到这里 只有一个watcher 渲染watchrer，只要视图中使用到了这个属性，而且属性变化了就要更新视图\n\nclass Watcher {\n    constructor(vm, exprOrFn, cb, options) {\n        this.vm = vm;\n        this.exprOrFn = exprOrFn;\n        this.cb = cb;\n        this.options = options;\n        this.deps = []; // 这个watcher会存放所有的dep\n        this.depsId = new Set();\n        if (typeof exprOrFn == 'function') {\n            this.getter = exprOrFn;\n        }\n\n        this.id = id++;\n        this.get();\n    }\n    run(){\n        this.get(); // 重新渲染\n    }\n    get() {\n        // 1.是先把渲染watcher 放到了 Dep.target上\n        // 2.this.getter()  是不是去页面取值渲染  就是调用defineProperty的取值操作\n        // 3.我就获取当前全局的Dep.target,每个属性都有一个dep 取值是就将Dep.target 保留到当前的dep中\n        // 4.数据变化 通知watcher 更新 \n\n        pushTarget(this); // 在取值之前 将watcher先保存起来\n        this.getter(); // 这句话就实现了视图的渲染  -》 操作是取值 \n        popTarget(); // 删掉watcher\n\n        // Vue是组件级别更新的\n    }\n    addDep(dep) {\n        let id = dep.id;\n        if (!this.depsId.has(id)) {\n            this.depsId.add(id);\n            this.deps.push(dep);\n            dep.addSub(this); // 让当前dep 订阅这个watcher\n        }\n    } \n    update(){ // 更新原理\n        queueWatcher(this); // 将watcher存储起来\n        // this.get();  // 以前调用get方法是直接更新视图\n    }\n}\n\n\nexport default Watcher","export function patch(oldVnode, newVnode) {\n    const isRealElement = oldVnode.nodeType;\n    if (isRealElement) {\n        // 真实元素\n        const oldElm = oldVnode;\n        const parentElm = oldElm.parentNode;\n        let el = createElm(newVnode);\n        parentElm.insertBefore(el, oldElm.nextSibling)\n        parentElm.removeChild(oldElm);\n        return el; // 渲染的真实dom\n    } else {\n        // dom diff 算法  同层比较 （默认想完整比对一棵树 O(n^3)）  O(n)\n        // 不需要跨级比较\n\n        // 两棵树 要先比较树根一不一样，再去比儿子长的是否一样\n\n        if (oldVnode.tag !== newVnode.tag) { // 标签名不一致 说明是两个不一样的节点\n            oldVnode.el.parentNode.replaceChild(createElm(newVnode), oldVnode.el);\n        }\n        // 标签一致 div  都是文本 tag = undefined\n\n        if (!oldVnode.tag) { // 如果是文本 文本变化了 直接用新的文本替换掉老的文本\n            if (oldVnode.text !== newVnode.text) {\n                oldVnode.el.textContent = newVnode.text;\n            }\n        }\n        // 一定是标签了 而且标签一致\n        // 需要复用老的节点 替换掉老的属性\n        let el = newVnode.el = oldVnode.el;\n        // 更新属性  diff 属性\n        updateProperties(newVnode, oldVnode.data); // 此时属性就更新完毕了 当前的树根已经完成了\n\n        // 比对孩子节点\n        let oldChildren = oldVnode.children || []; // 老的孩子\n        let newChildren = newVnode.children || []; // 新的孩子\n\n        // 新老都有孩子 那就比较 diff核心\n        // 老的有孩子 新的没孩子 直接删除\n        // 新的有孩子  老的没孩子 直接插入\n\n        if (oldChildren.length > 0 && newChildren.length > 0) {\n            // diff  两个人都有儿子 ** 这里要不停的去比较孩子节点\n            updateChildren(el, oldChildren, newChildren);\n            // 通过比较老孩子和新孩子 操作el中的儿子\n\n        } else if (oldChildren.length > 0) {\n            el.innerHTML = '';\n        } else if (newChildren.length > 0) {\n            for (let i = 0; i < newChildren.length; i++) {\n                let child = newChildren[i]; // 拿到一个个的孩子\n                el.appendChild(createElm(child)); // 浏览器会自动优化\n            }\n        }\n        return el;\n    }\n}\n\nfunction isSameVnode(oldVnode, newVnode) {\n    return (oldVnode.key == newVnode.key) && (oldVnode.tag === newVnode.tag);\n}\n\nfunction updateChildren(parent, oldChildren, newChildren) {\n    // Vue2.0 使用双指针的方式 来进行比对\n    // v-for 要有key  key可以标识元素 是否发生变化 前后的key相同则可以复用这个元素\n\n    let oldStartIndex = 0; // 老的开始的索引\n    let oldStartVnode = oldChildren[0]; // 老的开始\n    let oldEndIndex = oldChildren.length - 1; // 老的尾部索引\n    let oldEndVnode = oldChildren[oldEndIndex]; // 获取老的孩子的最后一个\n\n    let newStartIndex = 0; // 老的开始的索引\n    let newStartVnode = newChildren[0]; // 老的开始\n    let newEndIndex = newChildren.length - 1; // 老的尾部索引\n    let newEndVnode = newChildren[newEndIndex]; // 获取老的孩子的最后一个\n\n    function makeIndexByKey(children) { // 只需要创建一次 映射表\n        let map = {};\n        children.forEach((item, index) => {\n            map[item.key] = index;\n        })\n        return map\n    }\n    let map = makeIndexByKey(oldChildren); // 根据老的孩子的key 创建一个映射表 \n    // 1方案1 先开始从头部进行比较  O(n)  优化向后插入的逻辑\n    // 比较时 就是采用最短的进行比较，剩下的要不是删除要么是增加\n    while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n        // 如何判断 两个虚拟节点是否一致 就是用key + type 进行判断\n        if (!oldStartVnode) {\n            oldStartVnode = oldChildren[++oldStartIndex];\n        } else if (!oldEndVnode) {\n            oldEndVnode = oldChildren[--oldEndIndex]\n        } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            //标签和key一致 但是 元素可能属性不一致\n            patch(oldStartVnode, newStartVnode); //自身属性 +  递归比较\n            oldStartVnode = oldChildren[++oldStartIndex];\n            newStartVnode = newChildren[++newStartIndex];\n            //  指针不停的在动\n        } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            // 2 方案2  从尾部开始比较 如果头部不一致 开始尾部比较， 优化向前插入\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldChildren[--oldEndIndex]; // 移动尾部指针\n            newEndVnode = newChildren[--newEndIndex];\n        } else if (isSameVnode(oldStartVnode, newEndVnode)) { // 正序  和 倒叙  reverst sort\n            // 3方案3 头不一样 尾不一样  头移尾  倒序操作\n            patch(oldStartVnode, newEndVnode);\n            parent.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling); // 具备移动性\n            oldStartVnode = oldChildren[++oldStartIndex];\n            newEndVnode = newChildren[--newEndIndex];\n        } else if (isSameVnode(oldEndVnode, newStartVnode)) { // 老的尾 和新的头比对\n            patch(oldEndVnode, newStartVnode);\n            parent.insertBefore(oldEndVnode.el, oldStartVnode.el)\n            oldEndVnode = oldChildren[--oldEndIndex];\n            newStartVnode = newChildren[++newStartIndex];\n        } else {\n            // 乱序比对  最终处理\n            let moveIndex = map[newStartVnode.key];\n            if (moveIndex == undefined) { // 是一个新元素 ，应该添加进去\n                parent.insertBefore(createElm(newStartVnode), oldStartVnode.el)\n            } else {\n                let moveVnode = oldChildren[moveIndex];\n                oldChildren[moveIndex] = null; // 占位 如果直接删除 可能会导致数组塌陷  [a,b,null,d]\n\n                // 比对当前这两个元素属性和儿子\n                patch(moveVnode, newStartVnode);\n                parent.insertBefore(moveVnode.el, oldStartVnode.el);\n            }\n            newStartVnode = newChildren[++newStartIndex]; // 移动新的指针\n        }\n\n    }\n    if (newStartIndex <= newEndIndex) {\n        for (let i = newStartIndex; i <= newEndIndex; i++) {\n            // appendChild   =  insertBefore null  js原生操作\n            let ele = newChildren[newEndIndex + 1] == null ? null : newChildren[newEndIndex + 1].el\n            parent.insertBefore(createElm(newChildren[i]), ele);\n            // parent.appendChild(createElm(newChildren[i]))\n        }\n    }\n    if (oldStartIndex <= oldEndIndex) { // 说明新的已经循环完毕了 老的有剩余 剩余就是不要的\n        for (let i = oldStartIndex; i <= oldEndIndex; i++) {\n            let child = oldChildren[i];\n            if (child != null) {\n                parent.removeChild(child.el);\n            }\n        }\n    }\n\n    // 没有key 就直接比较类型，如果类型一样就复用 （隐藏的问题是儿子可能都需要重新创建）\n    // 循环时尽量采用唯一的标识 作为key 如果用索引（例如倒叙 会采用索引来复用，不够准确） 如果是静态数据 （你爱用啥用啥）\n\n\n    // 下周六 开班第一天 \n\n}\nexport function createElm(vnode) { // 需要递归创建\n    let { tag, children, data, key, text } = vnode;\n    if (typeof tag == 'string') {\n        // 元素 // 将虚拟节点和真实节点做一个映射关系 （后面diff时如果元素相同直接复用老元素 ）\n        vnode.el = document.createElement(tag);\n        updateProperties(vnode); // 跟新元素属性\n        children.forEach(child => {\n            // 递归渲染子节点 将子节点 渲染到父节点中\n            vnode.el.appendChild(createElm(child));\n        });\n    } else {\n        // 普通的文本\n        vnode.el = document.createTextNode(text);\n    }\n    return vnode.el\n}\n\nfunction updateProperties(vnode, oldProps = {}) {\n\n    // 需要比较 vnode.data 和 oldProps的差异\n\n    let el = vnode.el;\n    let newProps = vnode.data || {};\n    // 获取老的样式和新的样式的差异 如果新的上面丢失了属性 应该在老的元素上删除掉\n    let newStyle = newProps.style || {};\n    let oldStyle = oldProps.style || {};\n\n    for (let key in oldStyle) {\n        if (!newStyle[key]) {\n            el.style[key] = ''; // 删除之前的样式\n        }\n    }\n    for (let key in oldProps) {\n        if (!newProps[key]) { // 此时的元素一是以前\n            el.removeAttribute(key);\n        }\n    }\n\n    // 其他情况直接用新的值覆盖掉老的值即可\n    for (let key in newProps) {\n        if (key == 'style') {\n            for (let styleName in newProps.style) { // {color:red,background:green}\n                el.style[styleName] = newProps.style[styleName]\n            }\n            // 浏览器重新渲染也会看值是否变化\n        }\n        // event \n        else {\n            el.setAttribute(key, newProps[key]);\n        }\n    }\n}","import Watcher from './observer/watcher';\nimport { patch } from './vdom/patch';\nexport function lifeCycleMixin(Vue) {\n    Vue.prototype._update = function(vnode) {\n        const vm = this;\n\n        // 将虚拟节点 变成 真实节点 替换掉$el\n\n        // 后续 dom diff 也会执行此方法\n\n\n        vm.$el = patch(vm.$el, vnode);\n\n    }\n}\nexport function mountComponent(vm, el) {\n    // Vue在渲染的过程中 会创建一个 所谓的“渲染watcher ” 只用来渲染的\n    // watcher就是一个回调 每次数据变化 就会重新执行watcher\n\n\n    // Vue是不是MVVM框架\n    callHook(vm, 'beforeMount')\n    const updateComponent = () => {\n        // 内部会调用刚才我们解析后的render方法 =》 vnode\n        // _render => options.render 方法\n        // _update => 将虚拟dom 变成真实dom 来执行\n        console.log('update')\n        vm._update(vm._render());\n    }\n\n    // 每次数据变化 就执行 updateComponent 方法 进行更新操作\n    new Watcher(vm, updateComponent, () => {}, true);\n\n    callHook(vm, 'mounted');\n\n\n\n    // vue 响应式数据的规则 数据变了 视图会刷新\n}\n\n\nexport function callHook(vm, hook) { // vm.$options\n    let handlers = vm.$options[hook]; // 典型的发布订阅模式\n    if (handlers) {\n        for (let i = 0; i < handlers.length; i++) { // [fn,fn,fn]\n            handlers[i].call(vm); // 所有的生命周期的this 指向的都是当前的实例\n        }\n    }\n}","import { initState } from './state'\nimport { compileToFunctions } from './compiler/index.js'\nimport { mountComponent } from './lifecycle.js'\nexport function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n\n        const vm = this;\n        // Vue 内的$options 就是用户传入的所有参数\n        vm.$options = options\n\n        // 初始化状态\n        initState(vm)\n\n\n        // 根据模版进行渲染, 用户传入了el属性才执行挂载 $mount  否则要手动 \n        if (vm.$options.el) {\n            vm.$mount(vm.$options.el)\n        }\n    }\n    /**\n     * 传入的el可以是字符串 也可以是dom对象. 这里默认是string 源码中有判断 typeof el === 'string'\n     * 详见 171页\n     * 三者的优先级:  render > template > el\n     */\n    Vue.prototype.$mount = function (el) {\n        const vm = this;\n        el = vm.$el = document.querySelector(el)\n        // 如果render不存在 将模版编译成render函数 赋值给$options.render\n        const opts = vm.$options\n        if (!opts.render) {\n            let template = opts.template\n            if (!template && el) {\n                template = el.outerHTML;\n            }\n            const render = compileToFunctions(template)\n            opts.render = render;\n        }\n\n        // render存在 就不需要编译了 用户传入了一个render\n        // 挂载即可\n        mountComponent(vm, el)\n    }\n}","export function createTextVNode(text) {\n    return vnode(undefined, undefined, undefined, undefined, text);\n}\nexport function createElement(tag, data = {}, ...children) {\n    // vue中的key 不会作为属性传递给组件\n\n    \n    return vnode(tag, data, data.key, children)\n}\n// 虚拟节点是 产生一个对象 用来描述dom结构 增加自定义属性\n// ast 他是描述 dom语法的 \nfunction vnode(tag, data, key, children, text) {\n    return {\n        tag,\n        data,\n        key,\n        children,\n        text,\n    }\n}","import {createTextVNode,createElement} from './vdom/create-element'\nexport function renderMixin(Vue) {\n    Vue.prototype._v = function(text) {\n        // 创建文本的虚拟及诶点\n        return createTextVNode(text)\n    }\n    Vue.prototype._c = function() {\n        return createElement(...arguments);\n    }\n    Vue.prototype._s = function(val) {\n        // 判断当前这个值是不是对象 ，如果是对象 直接转换成字符串 ，防止页面出现[object Object]\n        return val == null ? '' : (typeof val === 'object' ? JSON.stringify(val) : val);\n    }\n    Vue.prototype._render = function() {\n        // 调用我们自己实现的render方法\n\n        const vm = this;\n        const { render } = vm.$options;\n\n       \n        let vnode = render.call(vm); // _c _c  _s\n        return vnode\n    }\n}","/**\n * vue使用的是rollup打包 它的特点是把多个小模块 组合成复杂的逻辑\n * rollup更专注于打包javascript类库\n * 开发应用的时候更推荐用webpack, 开发库时用rollup\n */\nimport { initMixin } from './init'\nimport { renderMixin } from './render.js'\nimport { lifeCycleMixin } from './lifecycle.js'\n\nfunction Vue(options) {\n    // 内部要进行初始化操作\n    this._init(options)\n}\n\n// 由于组件初始化 会有很多方法 在这里写一堆 Vue.prototype.methods 不优雅\n// 所以使用混入 更好 通过mixin引入\n\n// 在原型上添加属性或方法\ninitMixin(Vue)\nrenderMixin(Vue)\nlifeCycleMixin(Vue)\n\n\n\nexport default Vue"],"names":["oldArrayMethods","Array","prototype","arrayMethods","Object","create","methods","forEach","method","ob","__ob__","args","result","apply","inserted","slice","observeArray","console","log","isObject","obj","Observe","data","defineProperty","enumerable","configurable","value","isArray","__proto__","walk","i","length","observe","keys","key","defineReactive","get","set","newVal","initState","vm","opts","$options","props","initData","_data","call","hasOwnProperty","proxy","target","property","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","root","currentParent","stack","createASTElement","tagName","attrs","tag","children","parent","type","start","element","push","end","pop","chars","text","replace","textEnd","indexOf","startTageMatch","parseStartTag","endTagMatch","match","advance","substring","n","attr","name","defaultTagRE","genProps","str","split","item","JSON","stringify","gen","node","generate","test","tokens","lastIndex","index","exec","trim","join","genChildren","el","map","c","code","undefined","compileToFunctions","template","ast","render","Function","has","queue","flushSchedulerQueue","run","queueWatcher","watcher","id","nextTick","callbacks","pending","flushCallbacksQueue","fn","setTimeout","Watcher","exprOrFn","cb","options","deps","depsId","Set","getter","dep","add","addSub","patch","oldVnode","newVnode","isRealElement","nodeType","oldElm","parentElm","parentNode","createElm","insertBefore","nextSibling","removeChild","replaceChild","textContent","updateProperties","oldChildren","newChildren","updateChildren","innerHTML","child","appendChild","isSameVnode","oldStartIndex","oldStartVnode","oldEndIndex","oldEndVnode","newStartIndex","newStartVnode","newEndIndex","newEndVnode","makeIndexByKey","moveIndex","moveVnode","ele","vnode","document","createElement","createTextNode","oldProps","newProps","newStyle","style","oldStyle","removeAttribute","styleName","setAttribute","lifeCycleMixin","Vue","_update","$el","mountComponent","callHook","updateComponent","_render","hook","handlers","initMixin","_init","$mount","querySelector","outerHTML","createTextVNode","renderMixin","_v","_c","arguments","_s","val"],"mappings":"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"}