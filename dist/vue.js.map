{"version":3,"file":"vue.js","sources":["../src/observer/array.js","../src/utils.js","../src/observer/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["/**\n * 对数组的7个方法做函数劫持, 为什么是这7个呢? 因为只有他们能改变数组本身\n * ⚠️ 在实际应用中 操作数组索引改变数组 vue是检测不到的  list[0] = 100 ❌\n * 原理: 复制数组原型上的方法 对其中7个做函数劫持 AOP\n * 先执行自定义方法 再触发原型上的方法 apply \n */\n\nlet oldArrayMethods = Array.prototype;  // 获取数组原型上的方法\n\n// 创建一个全新的对象, 根据原型链可以找到数组原型上的方法, 而且拓展方法时 不会影响原数组的原型方法\nexport let arrayMethods = Object.create(oldArrayMethods)\n\nlet methods = [\n    'push',\n    'pop',\n    'unshift',\n    'shift',\n    'splice',\n    'sort',\n    'reserve'\n]\n\nmethods.forEach(method => {\n    arrayMethods[method] = function (...args) {\n        const ob = this.__ob__\n        let result = oldArrayMethods[method].apply(this, args)\n        let inserted;\n        switch (method) {\n            case 'push':\n            case 'unshift':\n                inserted = args\n                break;\n            case 'splice':\n                inserted = args.slice(2);\n                break;\n            default:\n                break;\n        }\n        inserted && ob.observeArray(inserted)\n        console.log('数组被观测了', inserted);\n        return result;\n    }\n})\n/**\n * 为什么7个方法 只对三个做了处理呢?\n * 因为 push、unshift、splice  可以新增属性. 其他几个不能新增\n * 做响应式处理的目标是对所有数据观测, 所以不是新增的数据 不用处理.虽然其他的方法也能让数组改变\n * 注意: 这一步只做观测, 使页面更新的是  触发依赖 不要混淆.\n * 观测和页面更新没有直接关系,观测是为收集、触发依赖做铺垫\n */","// 此处放所有的工具方法\n\n\nexport function isObject(obj) {\n    return typeof obj === 'object' && obj !== null\n}\nconst LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'mounted',\n    'beforeUpdate',\n    'updated'\n]\nlet strats = {};\nfunction mergeHook(parentVal,childVal){ // []\n    if(childVal){ // 如果 孩子有值 \n        if(parentVal){ // 父亲有值 就直接拼接\n            return parentVal.concat(childVal)\n        }else{ // 如果孩子有值父亲没值 就将孩子包装成数组\n            return [childVal] // Vue.options.beforeCreate = [childVal]\n        }\n    }else{\n        return parentVal; // 直接返回父亲，因为没有孩子  \n    }\n}\nLIFECYCLE_HOOKS.forEach(hook=>{\n    strats[hook] = mergeHook\n})\nexport function mergeOptions(parent,child){ // {...parent,...child}  {a:1.b:2}  {a:{a:{b:2}}}\n    const options = {}\n    // 如果父亲和儿子里都有一个属性 这个属性不冲突 \n    for(let key in parent){ // 处理父亲的所有属性\n        mergeField(key);\n    }\n    for(let key in child){ // 处理儿子的所有属性，如果父亲有的值 在第一个循环中就已经处理了\n        if(!parent.hasOwnProperty(key)){\n            mergeField(key);\n        }\n    }\n    function mergeField(key){\n        // 两个组件间 data是函数 \n\n        // 写代码时很忌讳 各种if else if else \n\n        // 策略模式 根据不同的属性 调用不同的策略  \n        if(strats[key]){\n            // 这里就包含了 mergeHook的逻辑\n            options[key] = strats[key](parent[key],child[key])\n        }else if(isObject(parent[key]) && isObject(child[key])){\n            options[key] = Object.assign(parent[key],child[key])\n        }else{\n            if(child[key] == null){\n                options[key] = parent[key];\n            }else{\n                options[key] = child[key]; // 用儿子的值 直接覆盖掉 父亲的值\n            }\n        }\n    } // 面试时 经常会提到对象间的合并\n    return options\n}\n","import { arrayMethods } from \"./array\";\nimport {isObject} from '../utils.js'\n\n/**\n * 为什么vue用function 这里用class? \n * 因为 Function构造函数方便扩展原型上的属性和方法, 这里不需要\n */\nclass Observe {\n    constructor(data) {\n        /**\n         * 1、添加一个__ob__响应式标示,代表data已经被观测过, 对象数组都有\n         * 2、data.__ob__  = this\n         * 在数据上就可以获取到ob属性, 指代的是 observe实例\n         */\n        Object.defineProperty(data, '__ob__', {\n            enumerable: false,\n            configurable: false,\n            value: this\n        })\n        /**\n         * 因为实际开发中通过索引操作数组的情况并不多, 如果这里通过拦截数组的索引 做响应式太浪费性能\n         * 所以 vue采用 函数劫持的方法 重写了 7个能改变数组本身的方法\n         * 这里判断一下是 对象 or 数组\n         * 利用原型链向上查找的特性,使得数组改变的方法从arrayMethods中取到\n         */\n        if (Array.isArray(data)) {\n            data.__proto__ = arrayMethods;\n            this.observeArray(data)\n        } else {\n            this.walk(data)\n        }\n    }\n    /**\n     * 无论数组还是对象, 都要遍历其中的每一项 做响应式处理\n     */\n    observeArray(data) {\n        for (let i = 0; i < data.length; i++) {\n            observe(data[i]);\n        }\n    }\n    walk(data) {\n        Object.keys(data).forEach((key) => {\n            defineReactive(data, key, data[key])\n        })\n    }\n\n}\n\n/**\n * vue2.0 有性能问题: 递归重写get set 数据嵌套很大的话 性能很差. vue3 使用proxy得到优化🐂\n * \n */\n\nfunction defineReactive(data, key, value) {\n    observe(value) // value可能还是一个对象 递归循环检测一下\n    Object.defineProperty(data, key, {\n        get() {\n            console.log('对象的get方法');\n            return value\n        },\n        set(newVal) {\n            if (newVal === value) return\n            observe(newVal)\n            value = newVal\n            console.log('对象的set方法');\n        }\n    })\n}\n\n\nexport function observe(data) {\n    // 如果不是对象 就不用做响应式处理\n    if (!isObject(data)) {\n        return;\n    }\n    // 如果有__ob__属性    表示观测过 也直接跳出\n    if (data.__ob__ instanceof Observe) {\n        return;\n    }\n    // 返回一个observe实例, 观测的核心代码在这里, 一个对象 对应一个ob实例 \n    return new Observe(data)\n}","import { observe } from './observer/index'\nexport function initState(vm) {\n    const opts = vm.$options\n\n    if (opts.props) {\n        initProps(vm)\n    }\n    if (opts.methods) {\n        initMethod(vm)\n    }\n    if (opts.data) {\n        initData(vm)\n    }\n\n    function initProps(vm) {\n\n    }\n    function initMethod(vm) {\n\n    }\n    function initData(vm) {\n        // 这里就是如何做数据响应式的源码,首先拿到用户传入的数据\n        let data = vm.$options.data;\n\n        if (typeof data === 'function') {\n            data = vm._data = data.call(vm)\n        } else {\n            data = vm._data = data\n        }\n\n        // 把数据代理到vm实例上, 方便取的时候直接可以 vm.msg\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                proxy(vm, '_data', key)                \n            }\n        }\n        // 观测数据\n        observe(data)\n    }\n\n    function proxy(target, property, key){\n        Object.defineProperty(target, key, {\n            get(){\n                return target[property][key]\n            },\n            set(newVal){\n                target[property][key] = newVal\n            }\n        })\n    }\n}\n","import { initState } from './state'\nexport function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n\n        const vm = this;\n        // Vue 内的$options 就是用户传入的所有参数\n        vm.$options = options\n\n        // 初始化状态\n        initState(vm)\n\n    }\n}","/**\n * vue使用的是rollup打包 它的特点是把多个小模块 组合成复杂的逻辑\n * rollup更专注于打包javascript类库\n * 开发应用的时候更推荐用webpack, 开发库时用rollup\n * @param {*} options \n */\n\nimport {initMixin} from './init'\n\nfunction Vue(options) {\n    // 内部要进行初始化操作\n    this._init(options)\n}\n\n// 由于组件初始化 会有很多方法 在这里写一堆 Vue.prototype.methods 不优雅 \n// 所以使用混入 更好 通过mixin引入\n\n// 在原型上添加属性或方法 \ninitMixin(Vue)\n\n\n\nexport default Vue"],"names":["oldArrayMethods","Array","prototype","arrayMethods","Object","create","methods","forEach","method","ob","__ob__","args","result","apply","inserted","slice","observeArray","console","log","isObject","obj","Observe","data","defineProperty","enumerable","configurable","value","isArray","__proto__","walk","i","length","observe","keys","key","defineReactive","get","set","newVal","initState","vm","opts","$options","props","initData","_data","call","hasOwnProperty","proxy","target","property","initMixin","Vue","_init","options"],"mappings":"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"}